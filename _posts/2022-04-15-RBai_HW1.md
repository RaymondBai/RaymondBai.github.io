---
layout: post
title: HW1 - Visualizing Temperature Changes
---

Today we will create a SQL database, store data frames in it, then perform selective querying and create interactive visualizations using plotly.

# Key Imports
```python
import pandas as pd # data frame manipulation
import numpy as np # numeric manipulation
import sqlite3 # connection to SQL database
from plotly import express as px # plotly visualization
from sklearn.linear_model import LinearRegression # Regression
from plotly.io import write_html # for exporting plotly html
import datetime as dt # data/time manipulation
```

# Getting Data and Creating a database

We will read in the three relevant data frames: temperature, countries, stations.
```python
# Read in the temperature df
temps = pd.read_csv("temps_stacked.csv")
# Read in the countries df
countries = pd.read_csv('countries.csv')
# Read in the stations df directly from url
url = "https://raw.githubusercontent.com/PhilChodrow/PIC16B/master/datasets/noaa-ghcn/station-metadata.csv"
stations = pd.read_csv(url)
```

We first remove white space from data frame column names to avoid issues with SQL.
```python
# Substitute white space for underscore in df column names
countries = countries.rename(columns= {"FIPS 10-4": "FIPS_10_4"})
countries = countries.rename(columns= {"ISO 3166": "ISO_3166"})
```

Create a database and store the three data frames.
```python
# Create and connect to a temps.db database
conn = sqlite3.connect("temps.db")

# Add the three tables to temps.db
temps.to_sql("temperatures", conn,
             if_exists="replace", index=False)
stations.to_sql("stations", conn,
                if_exists="replace", index=False)
countries.to_sql("countries", conn,
                 if_exists="replace", index=False)

# close the connection after database construction
conn.close()
```

# Query Function

The query function connects to the database, joins the three tables by relevant country IDs, and returns one data frame for user-specified a) year duration b) month, and c) country.
```python
def query_climate_database(country, year_begin, year_end, month):
    # Connect to the database created before
    conn = sqlite3.connect("temps.db")
    # SQL command for joining the tables and
    # returning the desired columns
    cmd = '''
    SELECT
        s.NAME, s.LATITUDE, s.LONGITUDE, c.Name Country, t.Year, t.Month, t.Temp
    FROM
        temperatures t
    LEFT JOIN stations s ON t.ID = s.ID
    LEFT JOIN countries c ON SUBSTR(t.ID, 1, 2) = c.FIPS_10_4
    '''
    # Execute the SQL command and store the queried data into df
    df = pd.read_sql_query(cmd, conn)
    # Close the database connection
    conn.close()
    # Return entries that follow user specifications
    return df.loc[(df.Country == country) & (df.Month == month) &
                  (df.Year >= year_begin) & (df.Year <= year_end)].reset_index().drop('index', axis = 1)
```

# Geographic Scatter Function for Yearly Temperature Increases

First we create a function that can take in a data frame like we created before and calculate best-fit lines' slopes, giving us an estimated average temperature change per station.
```python
# The function takes in a data frame (with Year and Temp columns)
# Regresses on the data and returns the best fit line's slope
def coef(data_group):
    X = data_group[["Year"]] # expect data frame, not series
    y = data_group["Temp"] # expect data frame, not series
    LR = LinearRegression() # instantiate a LinearRegression object
    LR.fit(X, y) # Use fit method to fit the data points
    slope = LR.coef_[0] # extract the regression line's slope
    return slope
```
Then we create a function that takes in criterias (country, year_begin, year_end, month) as before, as well as `min_obs`, the minimal number of years of data that must be present for a station to be included in our visualization. `*kwargs` is also included to allow unspecified number of additional parameters for the plotly function from the user.
```python
def temperature_coefficient_plot(country, year_begin, year_end,
                                 month, min_obs, **kwargs):
    # Querying the user-specified data
    raw = query_climate_database(country = country, 
                                 year_begin = year_begin, 
                                 year_end = year_end,
                                 month = month)
    # Calculate how many years of data is present
    # per station per month
    freq = pd.DataFrame(raw.groupby(['NAME', 'Month'])['Temp'].transform(len)).rename(columns={'Temp':'freq'})
    # Join the frequency back to the raw data frame
    raw = raw.join(freq)
    # Keep only the rows where there are at least min_obs years of data
    filtered = raw[raw.freq >= min_obs]
    # Calculate the average temperature change (round to 4 decimals)
    temp_change = filtered.groupby(["NAME", "Month"]).apply(coef).reset_index()
    temp_change = temp_change.rename(columns = {0:"slope"}).round(decimals = 4)
    # Merge the temp_change table back
    df = temp_change.merge(filtered[["NAME", "LATITUDE", "LONGITUDE"]], left_on = "NAME", right_on = "NAME")
    # Create plotly scatter plot with map background
    # Allowing non-specified number of user-given parameters
    fig = px.scatter_mapbox(df, # data for the points you want to plot
                            lat = "LATITUDE", # col name for latitude
                            lon = "LONGITUDE", # col name for longitude
                            hover_name = "NAME", # hover bold text
                            color="slope", # represent temp using color
                            labels = {'''slope":"Estimated Yearly Increase (Celcius)'''},
                            **kwargs) # remaining user-specified arguments
    # Appropriate white space around the plots for aesthetics
    fig.update_layout(margin={"r":0,"t":50,"l":20,"b":0})
    return fig
```

### Scatter Map Plot for India:
{% include geographic_scatter_india.html %}

### Scatter Map Plot for China:
{% include geographic_scatter_china.html %}

