---
layout: post
title: Movie Recommender
---

Today we will recommend some movies that a user may enjoy based on common actors/actresses that appear in their favorite movie. Here is the repository: [Movie Recommender](https://github.com/RaymondBai/Movie-Recommender)

We will need scrapy to scrape actor and movie/TV show data from IMDB first, before we can do any analysis on movie recommendation. Let's get started!

# Key Imports

```python
import scrapy # For webscraping
import pandas # For manipulating data frames
```

# Scrapy spider

We wrote an ImdbSpider class which, when we run from the terminal, will access the IMDB site for the user's favorite movie (Here we use [The Dark Knight](https://www.imdb.com/title/tt0468569/), a brilliant piece of work by Nolan), find the actors in the film, go to their pages, and scrape the films that they have acted in. This entire process is accomplished using three functions, which we detail below:

## From the initial movie page

```python
def parse(self, response):
  '''
  From the initial movie page, find the cast list link
  Moves to that page, then call the next function
  parse_full_credits
  
  Output: None
  '''
  # Find the link modifier using CSS tags, class, and attribute
  to_append = response.css('a.ipc-metadata-list-item__icon-link').attrib['href']
  # Append the link modifier to get the link to go to
  cast_page = response.urljoin(to_append)
  # Go to the Cast list page and call the next function
  yield scrapy.Request(cast_page, callback = self.parse_full_credits)
```

Here is how this part works:
- We identify the css tag and class that correspond to the "All Cast & Crew" button "a.ipc-metadata-list-item__icon-link" and use its attribute "href" to get the underlying link modifier
- We take advantage of scrapy's `.urljoin()` to automatically join the modifier with the current link, thus giving us the full link for the next page
- With `scrapy.Request()`, the code simulates "clicking on and going to the 'All Cast & Crew'" by requesting and accessing the link we just created above.
- Once we are there, we will run the parse_full_credits function

## From the Cast & Crew page

```python
def parse_full_credits(self, response):
  '''
  From the Cast & Crew page, find every cast member's page
  Moves to each of those pages and call the next function
  parse_actor_page function
  
  Output: None
  '''
  # For every actor's headshot, find its underlying link to page
  actor_relative_paths = [a.attrib["href"] for a in response.css("td.primary_photo a")]
  # For every actor's page, move there and call the next function
  for a in actor_relative_paths:
    yield scrapy.Request(response.urljoin(a), callback = self.parse_actor_page)
```

Here is how this function works:
- From the full Cast & Crew page, we use the tag "td.primary_photo a" to locate the headshots of the cast members (credited and uncredited)
- We get the underlying link modifiers for those headshots, and take advantage of scrapy's `.urljoin()` to give us the full links for the actors' pages to go to
- With `scrapy.Request()`, the code simulates "clicking on each headshot to go to every cast member's personal IMDB pages" by requesting and accessing the links we just created above.
- For every actor's page we visit, run the parse_actor_page function

## From the Actor's personal page

```python
def parse_actor_page(self, response):
  '''
  From the Cast & Crew page, find every cast member's page
  Moves to each of those pages and call the next function
  parse_actor_page function
  
  Output:
  A dictionary for every film on which the actor has worked
  '''
  # Get the actor's name
  actor_name = str(response.css('h1.header span.itemprop::text')).split("data='")[-1].split("'")[0]
  # Then we go to the Filmography section and find all the films
  films = response.css('div.filmo-category-section div.filmo-row b a ::text').getall()
  # For each film, we output a dictionary.
  for film in films:
    yield {"actor": actor_name, "movie_or_TV_name": film}
```

We're almost there. Here's how we gathered all that data into an ouput csv:
- First get the actor's name
  + The actor's name is nested a few levels inside the header
  + We use two tags with class specification (h1.header ; span.itemprop) to get to it
  + We extract the name text without surrounding tags (::text)
  + The name appears at the end of some scrapy text, so we can extract using basic text manipulation
- Then we get the films that the actor has worked on
  + We access the Filmography section, then specify Actor parts only (div.filmo-category-section)
  + We then get all (`.getall()`) the film titles (div.filmo-row b a) and extract text only (::text) 
- For every film, output a dictionary that gives the actor's name and the film's title

## Putting Everything Together

Here is how everything fit together into the ImdbSpider class. We have specified the Dark Knight's IMDB file link as `start_urls`, and we have given this class a name `imdb_spider` to call it in the terminal later. When we call scrapy to execute this task, the output will be a data frame of two columns: actor and movie_or_TV_name.

```python
class ImdbSpider(scrapy.Spider):
    name = 'imdb_spider'
    start_urls = ['https://www.imdb.com/title/tt0468569/']

    def parse(self, response):
        to_append = response.css('a.ipc-metadata-list-item__icon-link').attrib['href']
        cast_page = response.urljoin(to_append)
        yield scrapy.Request(cast_page, callback = self.parse_full_credits)
    
    def parse_full_credits(self, response):
        actor_relative_paths = [a.attrib["href"] for a in response.css("td.primary_photo a")]
        for a in actor_relative_paths:
            yield scrapy.Request(response.urljoin(a), callback = self.parse_actor_page)
    
    def parse_actor_page(self, response):
        # find actor name
        actor_name = str(response.css('h1.header span.itemprop ::text')).split("data='")[-1].split("'")[0]
        # find list of films
        films = response.css('div.filmo-category-section div.filmo-row b a ::text').getall()
        for film in films:
            yield {
                "actor": actor_name,
                "movie_or_TV_name": film
                }
```

## Movie Recommendation

To recommend movies, we will compute a sorted list with the top movies and TV shows that share actors with the user's favorite movie or TV show.

```python
# Read in the csv file
movies = pd.read_csv("~/Desktop/PIC16B/Movie-Recommender/IMDB_scraper/DK_actors.csv")
# Remove duplicates in case actor is listed more than once
# for a single film on IMDB
movies.drop_duplicates(keep = 'first', inplace = True)
# Count the number of occurrences for each movie/TV show title
top_ten = movies.groupby("movie_or_TV_name").count()
# Sort the count by descending order and keep only the top ten
top_ten = top_ten.sort_values(by = "actor", axis = 0, ascending = False).head(10)
```

### Results
It comes as no surprise that "The Dark Knight" shares the highest number of actors as itself. 

![Frequency Barplot](/images/freq_bar.png)

I am surprised to see that these actors have not really come together often in other films, but the recommended films do fit my movie preference, which is in general more action and thriller oriented. Thanks, Scrapy!
